---
title: "ADMIXTOOLS 2 Torial"
author: "Robert Maier"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{ADMIXTOOLS 2 Torial}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


This tutorial gives an overview of the basic workflow for computing *f*-statistics, and for using *qpWave*, *qpAdm*, and *qpGraph*.
Documentation for each *ADMIXTOOLS 2* function can be found under *Reference*, and more detailed information about specific topics under *Articles*.

For the examples here and on the other pages, the following R packages need to be loaded.

```{r, results='hide', message=FALSE, warning=FALSE}
library(admixtools)
library(magrittr)
library(tidyverse)
```


## Introduction

*ADMIXTOOLS* is a set of programs used to infer population histories from *f*-statistics computed from genetic data. *ADMIXTOOLS 2* is a new implementation of these programs which can either be run through the `R` command line, or through a browser application.

The main use cases of the *ADMIXTOOLS* programs are:

* Finding out if a population is admixed between other populations ([$f_3$](admixtools.html#f3-and-qp3pop), [*qpAdm*](admixtools.html#qpwave-and-qpadm))
* Finding out if a set of populations forms a clade relative to another set, and if not, how many admixture waves separate the two sets ([$f_4$](admixtools.html#f3-and-qp3pop), [*qpWave*](admixtools.html#qpwave-and-qpadm))
* Fitting an admixture graph to a set of populations ([*qpGraph*](admixtools.html#qpgraph))


The browser application can be launched from R with the following command:
```{r, eval = FALSE}
library(admixtools)
run_shiny_admixtools()
```

This website focuses on the R command line interface.


*ADMIXTOOLS 2* divides the computations into two steps:

1. Computing $f_2$-statistics and storing them on disk. This can be slow since it accesses the genotype data.
2. Using $f_2$-statistics to fit models. This is fast because $f_2$-statistics are very compact compared to genotype data.

Because *f*-statistics form the basis for everything that follows, they will be covered first.


<br>


## *f*-statistics basics

$f_2$, $f_3$, and $f_4$ describe how populations are related to one another, and they form the basis of *ADMIXTOOLS*. Here we briefly describe what they are and how to compute them. Two excellent papers on f-statistics can be found [here](https://www.genetics.org/content/192/3/1065) and [here](https://www.genetics.org/content/202/4/1485).

$f_2$ is the average squared difference in allele frequencies between two populations. Upper case letters denote populations ($A$ and $B$) and lower case letters denote their allele frequencies ($a$ and $b$).

$$f_2(A,B) = \frac{1}{M} \sum_{j=1}^M(a_{j} - b_{j})^2$$


$f_4$ is the covariance of allele frequency differences between two pairs of populations, and at the same time the sum of four f2-statistics:
$$
\begin{equation}
\begin{aligned}
f_4(A, B; C, D) &= \frac{1}{M}\sum_{j=1}^M(a_{j} - b_{j})(c_{j} - d_{j}) \\ &= \frac{1}{2}(f_2(A, D) + f_2(B, C) - f_2(A, C) - f_2(B, D) )
\label{eq:f42}
\end{aligned}
\end{equation}
$$
If $A$ and $B$ form a clade relative to $C$ and $D$, there should not be any correlation in the allele frequency differences $A$ - $B$ and $C$ - $D$, so $f_4(A, B; C, D)$ should be zero. If $f_4(A, B; C, D)$ is significantly different from zero, it suggests that $A$ and $B$ are not a clade relative to $C$ and $D$.

$f_3$ is the covariance of allele frequency differences between two pairs of populations where one population is the same on both sides. $f_3$ is thus a special case of $f_4$, and can also be written as a sum of $f_2$.

$$
\begin{aligned}
f_3(A; B, C) &= f_4(A, B; A, C) \\ &= \frac{1}{2} (f_2(A, B) + f_2(A, C) - f_2(B, C))
\end{aligned}
$$

If $f_3(A; B, C)$ is negative, it means that the more similar allele frequencies are between $A$ and $B$, the more different they are between $A$ and $C$, which suggests that $A$ is admixed between $B$ and $C$, or populations close to them.


In practice, the estimation of *f*-statistics can be more complicated than shown here, because it needs to account for low sample counts, missing data, and differences in ploidy. This is described [here](fstats.html).

## *f*~2~ in *ADMIXTOOLS 2*

In *ADMIXTOOLS 2*, $f_2$-statistics are the foundation for all further analyses. They can be computed from genotype data and saved to disk with this command: 

```{r, eval = FALSE}
prefix = '/path/to/geno'
my_f2_dir = '/store/f2data/here/'

extract_f2(prefix, my_f2_dir)
```

This will look for genotype files in *packedancestrymap* or *PLINK* format, compute allele frequencies and blocked $f_4$-statistics for all pairs of populations defined in the `.ind` or `.fam` file, and write them to `my_f2_dir`. It is also possible to extract only a subset of the samples or populations by passing IDs to the `inds` and `pops` arguments in `extract_f2()`. To get a description of the arguemnts and to see examples of how to use it, type

```{r, eval = FALSE}
?extract_f2
```


Once finished, $f_2$-statistics for the populations of interest can be loaded using `f2_from_precomp()`:

```{r, echo = FALSE}
f2_blocks = example_f2_blocks
```
```{r, eval = FALSE}
f2_blocks = f2_from_precomp(my_f2_dir)
```

Or you can load only a subset of the populations:
```{r, eval = FALSE}
mypops = c('Denisova.DG', 'Altai_Neanderthal.DG', 'Vindija.DG')
f2_blocks = f2_from_precomp(my_f2_dir, pops = mypops)
```

If your data is so small that computing $f_2$-statistics doesn't take very long, you can skip writing the data to disk with `extract_f2()` and do everything in one step using `f2_from_geno()`:

```{r, eval = FALSE}
f2_blocks = f2_from_geno(my_f2_dir, pops = mypops)
```


`f2_blocks` is now a 3d-array with $f_2$-statistics for each population pair along dimensions 1 and 2, and each SNP block along the 3rd dimension.
```{r}
dim(f2_blocks)
```

The purpose of having separate estimates for each SNP block is to compute [jackknife or bootstrap standard errors](resampling.html) for any *f*-statistic, and for any other estimated parameter.

`f2_blocks` can be used like this:
```{r, eval = FALSE}
f2_blocks[,,1]                # f2-statistics of the 1st SNP block
apply(f2_blocks, 1:2, mean)   # average across all blocks
f2_blocks[pop1, pop2, ]       # f2(pop1, pop2) for all blocks
```

The names along the 3rd dimension contain the SNP block lengths: 
```{r}
block_lengths = parse_number(dimnames(f2_blocks)[[3]])
head(block_lengths)
```

If you want to try any of this without extracting and loading your own $f_2$-statistics, you can instead use `example_f2_blocks` which becomes available as you load `admixtools`.

<br>

[More information](fstats.html) on *f*-statistics in *ADMIXTOOLS 2*

<br>

## *f*~3~ and *qp3Pop*

The original *ADMIXTOOLS* program for computing $f_3$-statistics is called *qp3Pop*. In *ADMIXTOOLS 2*, you can compute $f_3$-statistics like this:

```{r}
pop1 = 'Denisova.DG'
pop2 = c('Altai_Neanderthal.DG', 'Vindija.DG')
pop3 = c('Chimp.REF', 'Mbuti.DG', 'Russia_Ust_Ishim.DG')
```
```{r, eval = FALSE}
qp3pop(f2_blocks, pop1, pop2, pop3)
```

Or, equivalently

```{r, eval = FALSE}
f3(f2_blocks, pop1, pop2, pop3)
```
```{r, echo = FALSE}
f3(example_f2_blocks, pop1, pop2, pop3)
```

This will compute f3-statistics for all combinations of `pop1`, `pop2`, and `pop3`.
`f3(f2_blocks)` will compute all possible combinations (which can be a large number). If only `pop1` is supplied, all combinations of populations in `pop1` will be computed.

<br>

## *f*~4~ and *qpDstat*

The original *ADMIXTOOLS* program for computing $f_4$-statistics is called *qpDstat*. As the name suggests, it computes *D*-statistics by default. To get $f_4$-statistics instead, the `f4mode` argument needs to set to `YES`. In *ADMIXTOOLS 2*, almost everything starts with $f_2$-statistics, so the `qpdstat`/`f4` function computes $f_4$-statistics by default.

```{r}
pop4 = 'Switzerland_Bichon.SG'
```
```{r, eval = FALSE}
f4(f2_blocks, pop1, pop2, pop3, pop4)
qpdstat(f2_blocks, pop1, pop2, pop3, pop4)
# two names for the same function
```

```{r, echo = FALSE}
f4(example_f2_blocks, pop1, pop2, pop3, pop4, verbose = FALSE)
```

The differences between $f_4$-statistics and *D*-statistics are usually negligible. However, it is still possible to compute *D*-statistics in *ADMIXTOOLS 2*, by providing genotype data as the first argument, and setting `f4mode = FALSE`:

```{r, eval = FALSE}
prefix = '/path/to/geno'
f4(prefix, pop1, pop2, pop3, pop4, f4mode = FALSE)
```

Computing $f_4$- or *D*-statistics from genotype data directly is slower, but it has the advantage that it avoids any problems that may arise from large amounts of missing data. More on this [here](fstats.html).


<br>

## *qpWave* and *qpAdm*

*qpWave* and *qpAdm* are two programs with diffent goals - *qpWave* is used for estimating the number of admixture events, and *qpAdm* is used for estimating admixture weights - but they perform almost the same computations. The key difference is that *qpWave* compares two sets of populations (`left` and `right`), while *qpAdm* is tests how a single `target` population (which can be one of the `left` populations) relates to `left` and `right`. In *ADMIXTOOLS 2*, both `qpadm()` and `qpwave()`require at least three arguments:

1. $f_2$-statistics
2. A set of left populations
3. A set of right populations

`qpadm()` additionally requires a `target` population as the 4th argument, which will be modelled as a mixture of `left` populations.


```{r}
left = c('Altai_Neanderthal.DG', 'Vindija.DG')
right = c('Chimp.REF', 'Mbuti.DG', 'Russia_Ust_Ishim.DG', 'Switzerland_Bichon.SG')
target = 'Denisova.DG'
pops = c(left, right, target)
```

Both functions will return $f_4$-statistics, and a data frame that shows how well the $f_4$-matrix can be approximated by lower rank matrices. The last line tests for rank 0, which is equivalent to testing whether the left populations form a clade with respect to the right populations.

```{r, eval = FALSE}
results = qpwave(f2_blocks, left, right)
```
```{r, echo = FALSE}
results = qpwave(example_f2_blocks, left, right, verbose = FALSE)
```
```{r}
results$f4
results$rankdrop
```

`qpadm()` will also compute admixture weights and nested models:

* **weights**: These are the admixture weights, or estimates of the relative contributions of the left population to the target population.
* **popdrop**: popdrop shows the fits of all models generated by dropping a specific subset of left populations, and will only be returned if a target population is specified.
* **f4**: The estimated $f_4$-statistics will now also include lines with fitted $f_4$-statistics, where the target population is in the first column, and a weighted sum of the left populations, `fit`, in the second column.


```{r, eval = FALSE}
results = qpadm(f2_blocks, left, right, target)
```
```{r, echo = FALSE}
results = qpadm(example_f2_blocks, left, right, target, verbose = FALSE)
```
```{r}
results$weights
results$popdrop
```

<br>

The following two functions can be used to explore many *qpWave* or *qpAdm* models at the same time.

#### Pairwise cladality tests

`qpwave_pairs()` forms all pairs of `left` populations and tests whether they form a clade with respect to the `right` populations.

```{r, eval = FALSE}
qpwave_pairs(f2_blocks, left = c(target, left), right = right)
```
```{r, echo = FALSE}
qpwave_pairs(example_f2_blocks, left = c(target, left), right = right)
```


#### Rotating outgroups

`qpadm_rotate()` tests many `qpadm()` models at a time. For each model, the `left` populations will be split into two groups: The first group will make up the actual `left` populations passed to `qpadm()`, while the second group will be added to the `right` populations.

```{r, eval = FALSE}
qpadm_rotate(f2_blocks, left = pops[3:7], right = pops[1:2], target = pops[1])
```
```{r, echo = FALSE}
qpadm_rotate(example_f2_blocks, left = pops[3:7], right = pops[1:2], target = pops[1])
```



<br>

## *qpGraph*

Single $f_3$- and $f_4$-statistics can tell us how three or four populations are related to each other. *qpGraph* generalizes this concept to any number of populations. It takes estimated $f_3$-statistics and the topology of an admixtgure graph, finds the edges weights that minimize the difference between fitted and estimated $f_3$-statistics, and summarizes that difference in a likelihood score.


```{r, eval = FALSE}
qpg_results = qpgraph(f2_blocks, example_graph)
qpg_results$score
```
```{r, echo = FALSE}
qpg_results = qpgraph(example_f2_blocks, example_graph)
qpg_results$score
```

Here, `example_graph` is a specific graph included in this R package, but you can provide any other graph in one of three formats.

1. An [igraph](https://igraph.org/r/) object.
2. A two column matrix or data frame, where each row is an edge, the first column is the source of the edge, and the second column is the target. Additional columns labelled `lower` and `upper` can be used to constrain certain edges (`NA` = no constraint).
3. The location of a *qpGraph* graph file, which will be read and parsed.

The leaf nodes of this graph have to match the $f_2$-statistic population labels, and the graph has to be a valid admixture graph: a directed acyclic graph where each node has no more than two parents. If nodes with more than two children are present (polytomies or multifurcations) they will be split in a random order, and the new drift edges will be constrained to 0.

<br>


The output of `qpgraph()` is a list with several items:

* **edges**: A data frame with estimated edge weights. This includes normal edges as well as admixture edges.
* **score** The likelihood score. Smaller scores indicate a better fit.
* **f2** Estimated $f_2$-statistics and standard errors for all population pairs
* **f3** Estimated and fitted $f_3$-statistics for all population pairs with the outgroup. This includes residuals and z-scores.
* **opt** A data frame with details from the weight optimization, with one row per set of starting values.
* **ppinv** The inverse of the $f_3$-statistics covariance matrix

Optionally, fitted and estimated $f_4$-statistics are returned as **f4** and the worst residual z-score as **worst_residual** if `return_f4` is set to `TRUE`. When `f2_blocks_test` is provided, an out-of-sample score is computed and returned as **score_test**.

The fitted graph can be plotted like this:

```{r}
plot_graph(qpg_results$edges)
```

or as an interactive plot if you want to know the names of the inner nodes:

```{r, warning = FALSE}
plotly_graph(qpg_results$edges)
```

<br>


### More about graphs

*ADMIXTOOLS 2* can automatically find well-fitting graphs, and it has several functions for exploring the topological neighborhood of a graph. These functions are described [here](graphs.html).

To get a better theoretical understanding of *f*-statistics and admixture graphs, I recommend [this paper](https://onlinelibrary.wiley.com/doi/abs/10.1111/1755-0998.13230).

<br>


## Comparing results to *ADMIXTOOLS*

There are wrapper function which call the origial *ADMIXTOOLS* programs and read the results. This can be used to check if the results of `qpgraph()` are correct.

```{r, eval = FALSE}
binpath = '/home/np29/o2bin/'
env = 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/n/app/openblas/0.2.19/lib/:/n/app/gsl/2.3/lib/;'

qp3pop_bin  = paste0(env, binpath, 'qp3pop')
qpdstat_bin = paste0(env, binpath, 'qpDstat')
qpadm_bin   = paste0(env, binpath, 'qpAdm')
qpgraph_bin = paste0(env, binpath, 'qpGraph')

#prefix = '/n/groups/reich/DAVID/V42/V42.1/v42.1'
prefix = '/n/groups/reich/robert/projects/admixprograms/v42.1_small'
outdir = 'write/files/here/'

qp3pop_wrapper(source1 = pop2, source2 = pop3, target = pop1,
               qp3pop_bin, prefix, outdir)
qpdstat_wrapper(pop1, pop2, pop3, pop4,
                qpdstat_bin, prefix, outdir)
qpadm_wrapper(left, right, target,
              qpadm_bin, prefix, outdir)
qpgraph_wrapper(example_graph,
                qpgraph_bin, prefix, outdir)
```
**Unless `outdir` is specified, calling these wrapper functions may overwrite files in the working directory!**

If you already have existing parameter files and population or graph files, you can run the wrapper functions like this (though the different programs will require different parfiles and popfiles):

```{r, eval = FALSE}
qp3pop_wrapper (parfile = 'parfile.txt', bin = qp3pop_bin)
qpdstat_wrapper(parfile = 'parfile.txt', bin = qpdstat_bin)
qpadm_wrapper  (parfile = 'parfile.txt', bin = qpadm_bin)

qp3pop_wrapper ('popfile.txt', bin = qp3pop_bin,  pref = prefix)
qpdstat_wrapper('popfile.txt', bin = qpdstat_bin, pref = prefix)

qpadm_wrapper(left = 'left.txt', right = 'right.txt', bin = qpadm_bin, pref = prefix)

qpgraph_wrapper('graphfile.txt', parfile = 'parfile.txt', bin = qpgraph_bin)
```


<br>

The following function makes it easy to compare *qpGraph* or *qpAdm* results.

```{r, eval = FALSE}
qpgraph_ref_results = qpgraph_wrapper(example_graph, qpgraph_bin, prefix)
```
```{r, echo = FALSE}
qpgraph_ref_results = example_qpgraph_ref_results
```

```{r}
plot_comparison(qpg_results, qpgraph_ref_results)
```

This is not only useful for comparing results between *ADMIXTOOLS* and *ADMIXTOOLS 2*, but also for comparing models which used different parameters.

The interactive `plotly_comparison()` makes it easier to identify outliers.

```{r, eval = FALSE}
qpg_results2 = qpgraph(f2_blocks, example_graph, lsqmode = TRUE)
```
```{r, echo = FALSE}
qpg_results2 = qpgraph(example_f2_blocks, example_graph, lsqmode = TRUE)
```

```{r, warning = FALSE}
plotly_comparison(qpg_results, qpg_results2)
```
<br>





