---
title: "ADMIXTOOLS 2 Torial"
author: "Robert Maier"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{ADMIXTOOLS 2 Torial}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---


This tutorial gives an overview of the basic workflow for computing *f*-statistics, and using *qpWave*, *qpAdm*, and *qpGraph*.
Documentation for each ADMIXTOOLS function can be found under *Reference*, and more detailed information about specific topics under *Articles*.



## Introduction

Admixtools is a set of programs used to infer population histories from f-statistics computed from genetic data. ADMIXTOOLS 2 divides the computation into two steps:

1. Computing $f_2$-statistics and storing them on disk. This can be slow since it accesses the genotype data.
2. Using $f_2$-statistics to fit models. This is fast because $f_2$-statistics are very compact compared to genotype data.


ADMIXTOOLS 2 can either be run through the `R` command line, or through a browser application that can be launched like this:

```{r, eval = FALSE}
library(admixtools)
run_shiny_admixtools()
```

The documentation of the browser application can be accessed through the `?` in the upper right corner of the application window. This website documents the `R` command line interface.

For the examples below the following R packages need to be loaded.

```{r, results='hide', message=FALSE, warning=FALSE}
library(admixtools)
library(magrittr)
library(tidyverse)
```


<br>


## *f*-statistics

$f_2$, $f_3$, and $f_4$ describe how populations are related to one another, and they form the basis of ADMIXTOOLS. Here we briefly describe what they are and how to compute them. Two excellent papers on f-statistics can be found [here](https://www.genetics.org/content/192/3/1065) and [here](https://www.genetics.org/content/202/4/1485).

$f_2$ is the expected squared difference in allele frequencies between two populations $A$ and $B$. (Allele frequencies are denoted in lower case letters here.) We can estimate it by averaging over $M$ SNPs:
$$f_2(A,B) = \frac{1}{M} \sum_{j=1}^M(a_{j} - b_{j})^2$$


$f_4$ is the covariance of allele frequency differences between two pairs of populations, and at the same time the sum of four f2-statistics:
$$
\begin{equation}
\begin{aligned}
f_4(A, B; C, D) &= \frac{1}{M}\sum_{j=1}^M(a_{j} - b_{j})(c_{j} - d_{j}) \\ &= \frac{1}{2}(f_2(A, D) + f_2(B, C) - f_2(A, C) - f_2(B, D) )
\label{eq:f42}
\end{aligned}
\end{equation}
$$


$f_3$ is the covariance of allele frequency differences between two pairs of populations where one population is the same on both sides. $f_3$ is thus a special case of $f_4$, and can also be written as a sum of $f_2$.

$$
\begin{aligned}
f_3(A; B, C) &= f_4(A, B; A, C) \\ &= \frac{1}{2} (f_2(A, B) + f_2(A, C) - f_2(B, C))
\end{aligned}
$$


In practice, the estimation of f-statistics can be more complicated, as it needs to account for low sample counts, missing data, and differences in ploidy, as described [here](fstats.html).

In ADMIXTOOLS 2, f2-statistics are the foundation for all further analyses. They can be computed from genotype data and saved to disk with this command: 

```{r, eval = FALSE}
prefix = '/path/to/geno'
my_f2_dir = '/store/f2data/here/'

extract_f2(prefix, my_f2_dir)
```

This will look for genotype files in `packedancestrymap` or `PLINK` format, compute allele frequencies and blocked f2 statistics for all pairs of populations defined in the `.ind` or `.fam` file, and write them to `my_f2_dir`. It is also possible to extract only a subset of the samples or populations by passing IDs to the `inds` and `pops` arguments in `extract_f2`. To get a description of the arguemnts and to see examples of how to use it, type

```{r, eval = FALSE}
?extract_f2
```


Once finished, f2-statistics for the populations of interest can be loaded like this.

```{r, echo = FALSE}
f2_blocks = example_f2_blocks
```
```{r, eval = FALSE}
f2_blocks = f2_from_precomp(my_f2_dir)
```

Or you can load only a subset of the populations:
```{r, eval = FALSE}
mypops = c('Denisova.DG', 'Altai_Neanderthal.DG', 'Vindija.DG')
f2_blocks = f2_from_precomp(my_f2_dir, pops = mypops)
```


`f2_blocks` is now a 3d-array with f2-statistics for each population pair (along dimensions 1 and 2) and each SNP block (along the 3rd dimension).
```{r}
dim(f2_blocks)
```

Separate estimates for each SNP block make it possible to compute jackknife or bootstrap standard errors for any f-statistic, and for any other estimated parameter.

`f2_blocks` can be used like this:
```{r, eval = FALSE}
f2_blocks[,,1]                # f2-statistics of the 1st SNP block
apply(f2_blocks, 1:2, mean)   # average across all blocks
f2_blocks[pop1, pop2, ]       # f2(pop1, pop2) for all blocks
```

The names along the 3rd dimension contain the SNP block lengths: 
```{r}
block_lengths = parse_number(dimnames(f2_blocks)[[3]])
head(block_lengths)
```

If you want to try any of this without extracting and loading your own f2-statistics, you can instead use `example_f2_blocks` which becomes available as you load `admixtools`.

<br>

For more information on f-statistics in ADMIXTOOLS 2, click [here](fstats.html).

<br>

## qp3Pop

The original ADMIXTOOLS program for computing $f_3$-statistics is called *qp3Pop*. In ADMIXTOOLS 2, you can compute $f_3$-statistics like this:

```{r}
pop1 = 'Denisova.DG'
pop2 = c('Altai_Neanderthal.DG', 'Vindija.DG')
pop3 = c('Chimp.REF', 'Mbuti.DG', 'Russia_Ust_Ishim.DG')
```
```{r, eval = FALSE}
qp3pop(f2_blocks, pop1, pop2, pop3)
```

Or, equivalently

```{r, eval = FALSE}
f3(f2_blocks, pop1, pop2, pop3)
```
```{r, echo = FALSE}
f3(example_f2_blocks, pop1, pop2, pop3)
```

This will compute f3-statistics for all combinations of `pop1`, `pop2`, and `pop3`.
Typing just `f3(f2_blocks)` will compute all possible combinations (which can be a large number). If only `pop1` is supplied, all combinations of populations in `pop1` will be computed.

<br>

## qpDstat

The original ADMIXTOOLS program for computing $f_4$-statistics is called *qpDstat*. As the name suggests, it computes *D*-statistics by default. To get $f_4$-statistics instead, the `f4mode` argument needs to set to `YES`. In ADMIXTOOLS 2, almost everything starts with f2-statistics, so the `qpdstat`/`f4` function computes $f_4$-statistics by default.

```{r}
pop4 = 'Switzerland_Bichon.SG'
```
```{r, eval = FALSE}
f4(f2_blocks, pop1, pop2, pop3, pop4)
qpdstat(f2_blocks, pop1, pop2, pop3, pop4)
# two names for the same function
```

```{r, echo = FALSE}
f4(example_f2_blocks, pop1, pop2, pop3, pop4, verbose = FALSE)
```

The differences between $f_4$-statistics and D-statistics are usually negligible. However, it is still possible to compute D-statistics in ADMIXTOOLS 2, by providing genotype data as the first argument, and setting `f4mode = FALSE`:

```{r, eval = FALSE}
prefix = '/path/to/geno'
f4(prefix, pop1, pop2, pop3, pop4, f4mode = FALSE)
```

Computing $f_4$- or D-statistics from genotype data directly is slower, but it has the advantage that it avoids any problems that may arise from large amounts of missing data. More on this [here](fstats.html).


<br>

## qpWave and qpAdm

qpWave and qpAdm are two programs with diffent goals - one estimates the number of admixture events, the other admixture weights - but they perform the same computations. In ADMIXTOOLS 2, `qpadm` and `qpwave` are two names for one function. This function requires three arguments:

1. $f_2$-statistics
2. A set of left populations
3. A set of right populations

A target population, which will be modelled as a mixture of left populations, can be provided as the 4th argument.


```{r}
left = c('Altai_Neanderthal.DG', 'Vindija.DG')
right = c('Chimp.REF', 'Mbuti.DG', 'Russia_Ust_Ishim.DG', 'Switzerland_Bichon.SG')
target = 'Denisova.DG'
pops = c(left, right, target)
```

When no target population is provided (*qpWave* mode), the function will return $f_4$-statistics, and a data frame that shows how well the $f_4$-matrix can be approximated by lower rank matrices. The last line tests for rank 0, which is equivalent to testing whether the left populations form a clade with respect to the right populations.

```{r, eval = FALSE}
results = qpadm(f2_blocks, left, right)
```
```{r, echo = FALSE}
results = qpadm(example_f2_blocks, left, right, verbose = FALSE)
```
```{r}
results$f4
results$rankdrop
```

When a target population is provided (*qpAdm* mode), the following items will be returned in addition:

* **weights**: These are estimates of the relative contributions of the left population to the target population.
* **popdrop**: popdrop shows the fits of all models generated by dropping a specific subset of left populations, and will only be returned if a target population is specified.
* **f4**: The estimated f4-statistics will now also include lines with fitted f4-statistics, where the target population is in the first column, and a weighted sum of the left populations, `fit`, in the second column.


```{r, eval = FALSE}
results = qpadm(f2_blocks, left, right, target)
```
```{r, echo = FALSE}
results = qpadm(example_f2_blocks, left, right, target, verbose = FALSE)
```
```{r}
results$weights
results$popdrop
```

<br>

The following two functions can be used to explore many *qpWave* or *qpAdm* models at the same time.

#### Pairwise cladality tests

`qpadm_pairs` forms all pairs of *left* populations and tests whether they form a clade with respect to the *right* populations.

```{r, eval = FALSE}
qpadm_pairs(f2_blocks, left = c(target, left), right = right)
```
```{r, echo = FALSE}
qpadm_pairs(example_f2_blocks, left = c(target, left), right = right)
```


#### Rotating outgroups

```{r, eval = FALSE}
qpadm_rotate(f2_blocks, left = pops[3:7], right = pops[1:2], target = pops[1])
```
```{r, echo = FALSE}
qpadm_rotate(example_f2_blocks, left = pops[3:7], right = pops[1:2], target = pops[1])
```



<br>

## qpGraph

Single $f_3$- and $f_4$-statistics can tell us how three or four populations are related to each other. qpGraph generalizes this concept to any number of populations. It takes estimated $f_3$-statistics and the topology of an admixtgure graph, finds the edges weights that minimize the difference between fitted and estimated $f_3$-statistics, and summarizes that difference in a likelihood score.


```{r, eval = FALSE}
qpg_results = qpgraph(f2_dir, example_graph)
qpg_results$score
```
```{r, echo = FALSE}
qpg_results = qpgraph(example_f2_blocks, example_graph)
qpg_results$score
```

Here, `example_graph` is a specific graph included in this R package, but you can provide any other graph in one of three formats.

1. An [igraph](https://igraph.org/r/) object.
2. A two column matrix or data frame, where each row is an edge, the first column is the source of the edge, and the second column is the target. Additional columns labelled `lower` and `upper` can be used to constrain certain edges (`NA` = no constraint).
3. The location of a *qpGraph* graph file, which will be read and parsed.

The leaf nodes of this graph have to match the $f_2$-statistic population labels, and the graph has to be a valid admixture graph: a directed acyclic graph where each node has no more than two parents. If nodes with more than two children are present (polytomies or multifurcations) they will be split in a random order, and the new drift edges will be constrained to 0.

<br>


The output of `qpgraph` is a list with several items:

* **edges**: A data frame with estimated edge weights. This includes normal edges as well as admixture edges.
* **score** The likelihood score. Smaller scores indicate a better fit.
* **f2** Estimated f2-statistics and standard errors for all population pairs
* **f3** Estimated and fitted f3-statistics for all population pairs with the outgroup. This includes residuals and Z-scores.
* **opt** A data frame with details from the weight optimization, with one row per set of starting values.
* **ppinv** The inverse of the f3-statistics covariance matrix

Optionally, fitted and estimated f4-statistics can be returned by setting `return_f4 = TRUE`. When `f2_blocks_test` is provided, an out-of-sample score is computed and returned as **score_test**.

The fitted graph can be plotted like this:

```{r}
plot_graph(qpg_results$edges)
```

or as an interactive plot:

```{r, warning = FALSE}
plotly_graph(qpg_results$edges)
```

<br>


### More about graphs

ADMIXTOOLS 2 can automatically find well-fitting graphs, and it has several functions for exploring the topological neighborhood of a graph. These functions are described [here](graphs.html).

<br>


## Comparing results to ADMIXTOOLS

There are wrapper function which call the origial ADMIXTOOLS programs and read the results. This can be used to check if the results of `qpgraph` are correct.

```{r, eval = FALSE}
binpath = '/home/np29/o2bin/'
env = 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/n/app/openblas/0.2.19/lib/:/n/app/gsl/2.3/lib/;'

qp3pop_bin  = paste0(env, binpath, 'qp3pop')
qpdstat_bin = paste0(env, binpath, 'qpDstat')
qpadm_bin   = paste0(env, binpath, 'qpAdm')
qpgraph_bin = paste0(env, binpath, 'qpGraph')

#prefix = '/n/groups/reich/DAVID/V42/V42.1/v42.1'
prefix = '/n/groups/reich/robert/projects/admixprograms/v42.1_small'
outdir = 'write/files/here/'

qp3pop_wrapper(source1 = pop2, source2 = pop3, target = pop1,
               qp3pop_bin, prefix, outdir)
qpdstat_wrapper(pop1, pop2, pop3, pop4,
                qpdstat_bin, prefix, outdir)
qpadm_wrapper(left, right, target,
              qpadm_bin, prefix, outdir)
qpgraph_wrapper(example_graph,
                qpgraph_bin, prefix, outdir)
```
**Unless `outdir` is specified, calling these wrapper functions may overwrite files in the working directory!**

If you already have existing parameter files and population or graph files, you can run the wrapper functions like this (though the different programs will require different parfiles and popfiles):

```{r, eval = FALSE}
qp3pop_wrapper (parfile = 'parfile.txt', bin = qp3pop_bin)
qpdstat_wrapper(parfile = 'parfile.txt', bin = qpdstat_bin)
qpadm_wrapper  (parfile = 'parfile.txt', bin = qpadm_bin)

qp3pop_wrapper ('popfile.txt', bin = qp3pop_bin,  pref = prefix)
qpdstat_wrapper('popfile.txt', bin = qpdstat_bin, pref = prefix)

qpadm_wrapper(left = 'left.txt', right = 'right.txt', bin = qpadm_bin, pref = prefix)

qpgraph_wrapper('graphfile.txt', parfile = 'parfile.txt', bin = qpgraph_bin)
```


<br>

The following function makes it easy to compare qpGraph or qpAdm results.

```{r, eval = FALSE}
qpgraph_ref_results = qpgraph_wrapper(example_graph, qpgraph_bin, prefix)
```
```{r, echo = FALSE}
qpgraph_ref_results = example_qpgraph_ref_results
```

```{r}
plot_comparison(qpg_results, qpgraph_ref_results)
```
<br>





