---
title: "Using admixtools in R"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
---


For the examples below the following R packages need to be loaded.

```{r, results='hide', message=FALSE, warning=FALSE}
library("admixtools")
library("magrittr")
library("tidyverse")
```

<br>

## qpAdm


If you have access to pre-computed f2-statistics, you use them to compute admixture weights. The following should work on O2.

```{r}
target = 'Denisova.DG'
left = c('Altai_Neanderthal.DG', 'Vindija.DG')
right = c('Chimp.REF', 'Mbuti.DG', 'Russia_Ust_Ishim.DG', 'Switzerland_Bichon.SG')
```
```{r, eval = FALSE}
f2_dir = '/n/groups/reich/robert/projects/admixprograms/f2blocks_v41.1/'
qpadm(target, left, right, f2_dir = f2_dir)
```
```{r, echo = FALSE}
qpadm(target, left, right, f2_blocks, block_lengths)
```

Note that this only reports `qpAdm` admixture weights, and doesn't determine the number of independent source populations. The `qpadm` function also hasn't been tested as much as the `qpgraph` function, so the results may be wrong.

<br>

## qpGraph


The f2-statistics can also be used to fit an admixturegraph to the data.

```{r, eval = FALSE}
qpg_results = qpgraph(graph1, f2_dir = f2_dir)
```
```{r, eval = TRUE, echo = FALSE}
qpg_results = qpgraph(graph1, f2_blocks, block_lengths)
```

Here, `graph1` is a specific graph included in this R package, but it can be any other graph in one of three formats.

1. An [`igraph`](https://igraph.org/r/) object.
2. A two column matrix of edges, where the first column is the source of each edge, and the second column is the target.
3. The location of a `qpGraph` graph file, which will be read and parsed.

The only requirements for the input graph are that the graph is a valid admixturegraph - a DAG with one outgroup edge connecting the root to a leaf node - and that f2-statistics exist for all leaf nodes.

<br>

The `qpgraph` output is a list with five items:

1. A data frame with estimated edge weights. This includes normal edges as well as admixture edges
2. The likelihood score. Smaller scores indicate a better fit
3. The estimated f2-statistics and standard errors for all population pairs
4. The estimated f3-statistics and standard errors for all population pairs with the outgroup
5. A data frame with details from the weight optimization, with one row per set of starting values

```{r}
qpg_results$edges
```

<br>

This works for any populations for which there are precomputed f2-statistics.

```{r, eval = FALSE}
allpops = list.dirs(f2_dir, full.names = FALSE, recursive = FALSE)
rand_pops = sample(allpops, 20)
rand_graph = random_admixturegraph(rand_pops, numadmix = 5)
rand_results = qpgraph(rand_graph, f2_dir = f2_dir)
```

<br>


## Comparing results to AdmixTools

There are wrapper function which call the origial `AdmixTools` programs and read the results. This can be used to check if the results of `qpgraph` are correct.

```{r, eval = FALSE}
bin = 'path/to/qpGraph'
env = 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/n/app/openblas/0.2.19/lib/:/n/app/gsl/2.3/lib/;'
bin = paste(bin, env)
ref_results = qpgraph_wrapper2(graph1, bin, pref)
```
<br>

The following function makes it easy to compare the results.

```{r}
plot_comparison(qpg_results, ref_results)
```
<br>

There is at least one example where the results are pretty similar. Please let me know if you find examples where the results are different!


<br>

## Compute your own f2-statistics

If you're not on O2, or want use different f-statistics, you first have to compute allele frequencies for your populations of interest from data in `packedancestrymap` format.


```{r, eval = FALSE}
pops = c('Denisova.DG',
         'Altai_Neanderthal.DG',
         'Vindija.DG',
         'Chimp.REF',
         'Mbuti.DG',
         'Russia_Ust_Ishim.DG',
         'Switzerland_Bichon.SG')
prefix = '/n/groups/reich/DAVID/V41/V41.1/v41.1'
afdat = packedancestrymap_to_aftable(prefix, pops)
```

<br>

We also need to keep track of the number of samples in each population.

```{r, eval = FALSE}
indfile = read_table2(paste0(pref, '.ind'), col_names = c('iid', 'sex', 'group'))
popcounts = indfile %>% filter(group %in% pops) %$% table(group)
```

<br>

Reading the genotype data is rather slow, so it's a good idea to save the output.

```{r, eval = FALSE}
save(afdat, popcounts, 'my_afdat.RData')
```

<br>

Then you can use these allele frequencies to compute block-jackknife estimates of f2-statistics.

```{r, eval = FALSE}
## This assigns each SNP to a jackknife block, based on a 5 centimorgan genomic distance
block_lengths = get_block_lengths(afdat)
```

```{r, eval = FALSE}
## This computes the f2-statistics
f2_blocks = afs_to_f2_blocks(afs = afdat, popcounts = popcounts, block_lengths = block_lengths)
```

<br>

This also takes a while, so you should also save it.

```{r, eval = FALSE}
save(f2_blocks, block_lengths, 'my_f2_blocks.RData')
```
<br>

Now we can use this to compute admixture weights.

```{r, eval = FALSE}
qpadm(target, left, right, f2_blocks, block_lengths)
```
<br>

We can use the same f2-statistics as input for qpGraph.

```{r, eval = FALSE}
qpg_results = qpgraph(graph1, f2_blocks, block_lengths)
```

<br>

## Plot qpgraph results

This plots the `qpgraph` results.

```{r, out.height = "130%", out.width = "130%", fig.align="center"}
plot_graph(qpg_results$edges, color=TRUE)
```




<br>

## Find graphs with good fits

Since evaluating one graph doesn't take long once the f-statistics are pre-computed, we can evaluate many graphs and find graph topologies with good fits.

<br>

In order for that to be as fast as possible, we can precompute and reuse f3-statistics and the inverse of the f3-statistic covariance matrix.

```{r, eval = FALSE}
precomp = qpgraph_precompute(pops, f2_blocks, blockids)
f3_jest = precomp[[1]]
ppinv = precomp[[2]]
```
<br>

The function `optimize_admixturegraph` generates and evaluates `numgraphs` admixturegraphs in `numgen` iterations across `numrep` independent repeats to find well fitting admixturegraphs.

```{r, eval = FALSE}
opt_results = optimize_admixturegraph(pops, f3_jest, ppinv,
                                      numrep=200, numgraphs=100, numgen=20,
                                      numsel=5, numadmix=3)
```
<br>

Depending on the input parameters, `optimize_admixturegraph` can take a long time to run. With the parameters above, 420,000 admixture graphs (200 * 100 * (20+1)) will be generated and evaluated. Thanks to the function [`future_map`](https://www.rdocumentation.org/packages/furrr/versions/0.1.0/topics/future_map) from the [`furrr`](https://github.com/DavisVaughan/furrr) package it can be sped up by parallelizing across the independent repeats. The function [`future::plan`](https://www.rdocumentation.org/packages/future/versions/1.15.1/topics/plan) can be called to specify the details of the parallelization. This can be used to parallelize across cpu cores or across nodes on a compute cluster.

Setting it up like this will make it run multithreaded:
```{r, eval = FALSE}
future::plan('multiprocess')
```
<br>

On the O2 cluster, the following command will parallelize across compute nodes.

```{r, eval = FALSE}
future::plan(tweak(batchtools_slurm, workers=50,
                   resources=list(ncpus = 1, memory=1024,
                                  walltime=10*60*60, partition='short')))
```
This specifies that up to 50 jobs should be run at a time, with each one requesting one cpu, 1024 MB of memory, and 10 hours on the `short` partition.

This requires the R package `future.batchtools` and a batchtools template file in the working directory, such as this one: `/n/groups/reich/robert/projects/admixprograms/batchtools.slurm.tmpl`.

After that, the `optimize_admixturegraph` function will submit each of the 200 repeats as a separate job.

As it will still take a while for this to finish, it is a good idea to submit this as one job which calls an R script. That R script will in turn spawn 200 new jobs and wait for them to finish and return their results.

First, the input should be saved to a file.
```{r, eval = FALSE}
save(pops, f3_jest, ppinv, file = 'qpgraph_input.RData')
```

The R script could then look like this.
```{r, eval = FALSE}
library(admixtools)
library(future.batchtools)

load('qpgraph_input.RData')

future::plan(tweak(batchtools_slurm, workers=50,
                   resources=list(ncpus = 1, memory=1024,
                                  walltime=10*60*60, partition='short')))

opt_results = optimize_admixturegraph(pops, outpop = pops[1],
                                      f3_jest, ppinv, numrep = 200,
                                      numgen = 20, numgraphs = 100,
                                      numadmix = 3, verbose = FALSE)

save(opt_results, file='opt_results.RData')
```

It could be in a file called `opt_graphs.Rscript` and be run like this, or submitted as a job.
```{r, eval = FALSE}
Rscript opt_graphs.Rscript
```

<br>


Once that is done (and the results are loaded), the following commands will extract the best fitting model overall, and the best fitting model from each independent repeat.

```{r, eval = FALSE}
winner = opt_results %>% top_n(1, -jitter(score))
winners = opt_results %>% group_by(run) %>% top_n(1, -jitter(score)) %>% ungroup
```
```{r, out.height = "130%", out.width = "130%", fig.align="center"}
plot_graph(winner$edges[[1]])
```
<br>

## Summarize graphs

For any set of populations there may be many graphs which can explain the data well. The following function attempts to summarize a set of graphs by counting how often each population triple occurs in which configuration across all graphs.

```{r, eval = FALSE}
trip = summarize_triples(sel)
```
```{r}
trip %>% arrange(-clade) %>% slice(1)
```

The output for this population triple (1: `Rus`, 2: `Swi`, 3: `Den`) can be read like this:

* `numgraphs`: 200 graphs were compared
* `clade`: In 34.5% of all graphs `Rus` and `Swi` form a clade with respect to `Den`
* `x13`: In 0.5% of all graphs `Rus` is closer to `Den` than `Swi` is to `Den`, with ancestors of `Rus` admixing into `Den` 
* `x31`: In 50.5% of all graphs `Rus` is closer to `Den` than `Swi` is to `Den`, with ancestors of `Den` admixing into `Rus`
* `x23`: In 24.5% of all graphs `Swi` is closer to `Den` than `Rus` is to `Den`, with ancestors of `Swi` admixing into `Den` 
* `x32`: In 38.0% of all graphs `Swi` is closer to `Den` than `Rus` is to `Den`, with ancestors of `Den` admixing into `Swi`
* `toptopo`: The most common topology for this triple across all graphs. `011111` specifies a topology where condition `x13` is not satisfied, but conditions `x23`, `x31`, `x32`, `x12`, and `x21` are satisfied. A topology starting with `0000` is one where the first two populations form a clade.
* `toptopocnt`: The number of times `toptopo` was observed
* `topos`: The number of times each topology was observed


<br>



## Find valid qpAdm models

Every admixturegraph maps to a specific set of valid qpAdm models. This function lists the valid qpAdm models for each graph. Models which are contained within larger valid models are not shown. The number of valid qpAdm models can be very large for big graphs, so you should only run this on small graphs.

```{r, out.height = "130%", out.width = "130%", fig.align="center"}
mygraph = winners %>% slice(6) %$% igraph %>% pluck(1)
plot_graph(mygraph)
qpadm_models(mygraph, add_outgroup = TRUE, nested = FALSE, abbr = 3)
```

Valid qpAdm models need to satisfy the following criteria:

* There have to be more right populations than left populations
* The left populations should not form a clade with respect to any right population. This means that a qpgraph outgroup is not an informative outgroup, but it can be included anyway, with `add_outgroup`.
* Each set of left populations which forms a source for the target population has to form a clade with target at the exclusion of each right population. (Note: Check if that's correct and if it can be stated in a better way.)

The only qpAdm models which are valid under this graph have `Den` as target and `Chi`, `Rus`, and `Swi` as right populations.





