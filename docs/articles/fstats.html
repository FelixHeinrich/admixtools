<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>f-statistics • admixtools</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha256-U5ZEeKfGNOja007MMD3YBI0A3OSZOQbeG6z2f2Y0hu8=" crossorigin="anonymous"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/all.min.css" integrity="sha256-nAmazAk6vS34Xqo0BSrTb+abbtFlgsFK7NKSi6o7Y78=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.1/css/v4-shims.min.css" integrity="sha256-6qHlizsOWFskGlwVOKuns+D1nB6ssZrHQrNj1wGplHc=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/headroom.min.js" integrity="sha256-DJFC1kqIhelURkuza0AvYal5RxMtpzLjFhsnVIeuk+U=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.9.4/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><!-- docsearch --><script src="../docsearch.js"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.css" integrity="sha256-QOSRU/ra9ActyXkIBbiIB144aDBdtvXBcNc3OTNuX/Q=" crossorigin="anonymous">
<link href="../docsearch.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script><script src="../extra.js"></script><meta property="og:title" content="f-statistics">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-155330476-1"></script><script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-155330476-1');
</script>
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">admixtools</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">2.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/admixtools.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/fstats.html">f-statistics</a>
    </li>
    <li>
      <a href="../articles/graphs.html">Admixture graphs</a>
    </li>
    <li>
      <a href="../articles/io.html">Genotype data</a>
    </li>
    <li>
      <a href="../articles/parallel.html">Parallelization</a>
    </li>
    <li>
      <a href="../articles/plotting.html">Plotting</a>
    </li>
    <li>
      <a href="../articles/resampling.html">Standard errors</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/uqrmaie1/admixtools">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
<form class="navbar-form navbar-right hidden-xs hidden-sm" role="search">
        <div class="form-group">
          <input type="search" class="form-control" name="search-input" id="search-input" placeholder="Search..." aria-label="Search for..." autocomplete="off">
</div>
      </form>
      
    </div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>f-statistics</h1>
                        <h4 class="author">Robert Maier</h4>
            
            <h4 class="date">2020-09-11</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/uqrmaie1/admixtools/blob/master/vignettes/fstats.Rmd"><code>vignettes/fstats.Rmd</code></a></small>
      <div class="hidden name"><code>fstats.Rmd</code></div>

    </div>

    
    
<p><strong>Under construction</strong></p>
<p><em>f</em>-statistics are the foundation of <em>ADMIXTOOLS</em>. In <em>ADMIXTOOLS 2</em>, <span class="math inline">\(f_2\)</span>-statistics are of particular importance as <span class="math inline">\(f_3\)</span>- and <span class="math inline">\(f_4\)</span>-statistics are computed from <span class="math inline">\(f_2\)</span>-statistics. They are conceptually very simple, but estimating them without bias can be complicated.</p>
<p>Here, I give a summary of the basic theory behind <em>f</em>-statistics, and practical considerations for estimating them. <a href="https://www.genetics.org/content/192/3/1065">The paper which originally introduced <em>ADMIXTOOLS</em></a> goes into more detail.</p>
<div id="f2" class="section level2">
<h2 class="hasAnchor">
<a href="#f2" class="anchor"></a><em>f</em><sub>2</sub>
</h2>
<p><span class="math inline">\(f_2\)</span> is the expected squared difference in allele frequencies between two populations <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>.</p>
<p>In the simplest case, we can estimate <span class="math inline">\(f_2\)</span> across <span class="math inline">\(M\)</span> SNPs like this: <span class="math display">\[f_2(A,B) = \frac{1}{M} \sum_{j=1}^M(a_{j} - b_{j})^2 = \frac{1}{M} \sum_{j=1}^M a^2_{j} - 2 a_j b_j + b^2_{j}\]</span></p>
<p><span class="math inline">\(f_2\)</span> is closely related to the more widely used <span class="math inline">\(F_{ST}\)</span>. <span class="math inline">\(f_2\)</span> is the genetic variance between populations, and <span class="math inline">\(F_{ST}\)</span> is the ratio of between-population variance (<span class="math inline">\(f_2\)</span>) to total variance.</p>
<p><span class="math display">\[F_{ST}(A, B) = \frac{\sigma^2_{between}}{\sigma^2_{between}+\sigma^2_{within}} = \frac{f_2(A,B)}{f_2(A,B) + \frac{1}{M} \sum_{j=1}^M a_j(1-a_j) + b_j (1-b_j)}\]</span></p>
<p>One reason why <em>ADMIXTOOLS</em> uses <em>f</em>-statistics and not <span class="math inline">\(F_{ST}\)</span> is that <em>f</em>-statistics are additive: <span class="math inline">\(f_2(A, C) = f_2(A, B) + f_2(B, C)\)</span>. This holds under the assumptions that there is a large number of sites, genetic drift is neutral, and there are no backmutations or recurrent mutations.</p>
<p>In contrast, <span class="math inline">\(F_{ST}\)</span> is not additive. In fact, it doesn’t even satisfy the triangle inequality, which means that <span class="math inline">\(F_{ST}(A, C)\)</span> can be greater than <span class="math inline">\(F_{ST}(A, B) + F_{ST}(B, C)\)</span>.</p>
<p>On the other hand, <span class="math inline">\(f_2\)</span> has the disadvantage that its expectation depends on the allele frequency spectrum. This can be a problem when combining <em>f</em>-statistics from different populations pairs using different SNPs.</p>
<p><br></p>
<p>The estimator of <span class="math inline">\(f_2\)</span> shown above will only be unbiased only if have very accurate estimates of allele frequencies. This is often not the case because allele frequencies are estimated using only few samples in some populations. For this reason, we don’t estimate <span class="math inline">\(f_2\)</span> with the simple estimator shown above, but with the following estimator which is robust to changes in sample size:</p>
<p><span class="math display">\[f_2(A, B) = \frac{1}{M} \sum_{j=1}^M (a_j-b_j)^2 - \frac{a_j(1-a_j)}{n_{A,j}-1} - \frac{b_j(1-b_j)}{n_{B,j}-1}\]</span> <span class="math inline">\(n_{A,j}\)</span> and <span class="math inline">\(n_{B,j}\)</span> are the counts of independently sampled alleles in popoulations <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> at SNP <span class="math inline">\(j\)</span>. See <a href="#biases">Biases</a> for more information.</p>
</div>
<div id="f4" class="section level2">
<h2 class="hasAnchor">
<a href="#f4" class="anchor"></a><em>f</em><sub>4</sub>
</h2>
<p><span class="math inline">\(f_4\)</span> is the covariance of allele frequency differences between two pairs of populations. It can also be expressed as a sum of <span class="math inline">\(f_2\)</span>-statistics:</p>
<p><span class="math display">\[
\begin{equation}
\begin{aligned}
f_4(A, B; C, D) &amp;= \frac{1}{M}\sum_{j=1}^M(a_{j} - b_{j})(c_{j} - d_{j}) \\ &amp;= \frac{1}{M} \sum_{j=1}^M(- a_j d_j - b_j c_j + a_j c_j + b_j d_j) \\ &amp;= \frac{1}{2M} (\sum_{j=1}^M(a_j - d_j)^2 + \sum_{j=1}^M(b_j - c_j)^2 - \sum_{j=1}^M(a_j - c_j)^2 - \sum_{j=1}^M(b_j - d_j)^2) \\ &amp;= \frac{1}{2}(f_2(A, D) + f_2(B, C) - f_2(A, C) - f_2(B, D) )
\label{eq:f42}
\end{aligned}
\end{equation}
\]</span></p>
<p>This shows that <span class="math inline">\(f_4\)</span> is at the same time</p>
<ul>
<li>the covariance of allele frequency differences (line 1),</li>
<li>a sum of allele frequency products (line 2), and</li>
<li>a sum of <span class="math inline">\(f_2\)</span> statistics (line 4).</li>
</ul>
<p>By comparing the definitions of <span class="math inline">\(f_4\)</span> and <span class="math inline">\(f_2\)</span>, we also see that <span class="math inline">\(f_4\)</span> is a generalization of <span class="math inline">\(f_2\)</span>: <span class="math inline">\(f_4(A, B; A, B) = f_2(A, B)\)</span></p>
<p><em>D</em>-statistics differ from <span class="math inline">\(f_4\)</span> only by a scaling factor: <span class="math display">\[
\begin{equation}
\begin{aligned}
D(A, B; C, D) &amp;= \frac{P(ABBA) - P(BABA)}{P(ABBA) + P(BABA)} \\
&amp;= \frac{\frac{1}{M} \sum_{j=1}^M ((1-a_j)b_jc_j(1-d_j) + a_j(1-b_j)(1-c_j)d_j) - (a_j(1-b_j)c_j(1-d_j) + (1-a_j)b_j(1-c_j)d_j)}{\frac{1}{M} \sum_{j=1}^M ((1-a_j)b_jc_j(1-d_j) + a_j(1-b_j)(1-c_j)d_j) + (a_j(1-b_j)c_j(1-d_j) + (1-a_j)b_j(1-c_j)d_j)} \\
&amp;= \frac{f_4(A, B; C, D)}{\frac{1}{M} \sum_{j=1}^M (a_j + b_j - 2 a_j b_j)  (c_j + d_j - 2 c_j d_j)}
\end{aligned}
\end{equation}
\]</span> Here, <span class="math inline">\(P(ABBA)\)</span> is the probability of observing the same allele in populations <span class="math inline">\(A\)</span> and <span class="math inline">\(D\)</span>, and a different one in <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span>, and <span class="math inline">\(P(BABA)\)</span> is the probability of observing the same allele in populations <span class="math inline">\(A\)</span> and <span class="math inline">\(C\)</span>, and a different one in <span class="math inline">\(B\)</span> and <span class="math inline">\(D\)</span>.</p>
<p>Naively one might think that estimating <span class="math inline">\(f_4\)</span> without bias is at least as difficult as estimating <span class="math inline">\(f_2\)</span> without bias, but that is not the case. Since each population is represented in <span class="math inline">\(f_4\)</span> through two <span class="math inline">\(f_2\)</span> terms of opposite sign, many biases that are specific to one population will cancel out. This also applies to the low allele count correction factor <span class="math inline">\(\frac{p(1-p)}{n-1}\)</span>, which is not necessary when estimating <span class="math inline">\(f_4\)</span>.</p>
<p>For a visual interpretation of this effect, consider the following phylogeny:</p>
<pre><code>A         B
 \_______/
 /       \
C         D</code></pre>
<p><span class="math inline">\(f_2\)</span> is the total branch length between any two populations, while <span class="math inline">\(f_4(A, B; C, D)\)</span> is the length of the horizontal line. Any increase or decrease in the length of one of the terminal branches - say for example the branch leading to <span class="math inline">\(D\)</span> - will equally affect <span class="math inline">\(f_2(A, D)\)</span>, <span class="math inline">\(f_2(B, D)\)</span>, and <span class="math inline">\(f_2(C, D)\)</span>. But it will not affect <span class="math inline">\(f_4(A, B; C, D)\)</span> - the horizontal line. This robustness is a major strength of methods based on <span class="math inline">\(f_4\)</span>-statistics (and to a large extent also of <span class="math inline">\(f_3\)</span>-based methods): Terminal branch lengths are affected by many factors such as divergence time, changes in population size, as well as by data quality, but in expectation, none of this affects <span class="math inline">\(f_4\)</span>, the covariance of allele freuquency differences.</p>
<div id="f4-as-a-sum-of-allele-frequency-products" class="section level3">
<h3 class="hasAnchor">
<a href="#f4-as-a-sum-of-allele-frequency-products" class="anchor"></a><em>f</em><sub>4</sub> as a sum of allele frequency products</h3>
<p>In the presence of large amounts of missing data it is possible that not all biases cancel out when combining <span class="math inline">\(f_2\)</span>-statistics to <span class="math inline">\(f_4\)</span>-statistics. For this reason <span class="math inline">\(f_4\)</span>-statistics in <em>ADMIXTOOLS 2</em> can not only be computed by adding up <span class="math inline">\(f_2\)</span>-statistics, but also by adding up pairwise allele frequency products. While <span class="math inline">\(f_2\)</span> can be difficult to estimate without bias as described in the next section, allele frequencies and allele frequency products can easily be estimated without bias even with only one observed allele.</p>
</div>
</div>
<div id="biases" class="section level2">
<h2 class="hasAnchor">
<a href="#biases" class="anchor"></a>Biases</h2>
<div id="bias-due-to-inaccurate-allele-frequency-estimates" class="section level3">
<h3 class="hasAnchor">
<a href="#bias-due-to-inaccurate-allele-frequency-estimates" class="anchor"></a>Bias due to inaccurate allele frequency estimates</h3>
<p>Inaccurate allele frequency estimates lead to over-esimation of <span class="math inline">\(f_2\)</span>: If two populations have diverged very recently, their allele frequencies will be very similar. But if the allele frequencies of one or both population are estimated very inaccurately, the allele frequency differences (and <span class="math inline">\(f_2\)</span>) will appear larger than they really are.</p>
<p>The most common reason for inaccurate allele frequency estimates is low sample count (or a low number of independently sampled alleles). The upward bias due to low sample count at a single SNP in one population is <span class="math inline">\(\frac{p(1-p)}{n-1}\)</span>, where <span class="math inline">\(p\)</span> is the allele frequency and <span class="math inline">\(n\)</span> is the number of independently sampled alleles. Therefore, an unbiased estimate of <span class="math inline">\(f_2\)</span> at a single SNP is given by</p>
<p><span class="math display">\[f_2(A, B) = (a-b)^2 - \frac{a(1-a)}{n_A-1} - \frac{b(1-b)}{n_B-1}\]</span> Population-wide estimates of <span class="math inline">\(f_2\)</span> are again averages over all SNPs. In most cases, <span class="math inline">\(n\)</span>, the number of independently sampled alleles, will be twice the number of samples, with two exceptions:</p>
<p><em>1. Pseudohaploid data</em></p>
<p>Many ancient DNA data sets don’t call heterozygous genotypes in order to avoid a number of biases. If two different alleles are observed in one sample at a particular site, one of the two alleles is chosen at random and the genotype is declared homozygous for that allele. In pseudohaploid samples, the number of independently sampled alleles is therefore equal to the number of samples.</p>
<p><em>2. Inbreeding</em></p>
<p>If an individuals has closely related parents, his or her two parental chromosomes are more similar to each other than two chromosomes sampled at random from the population. In a population in which inbreeding is common, <span class="math inline">\(n\)</span> can therefore be less than two.</p>
<p>Some of the programs in the original <em>ADMIXTOOLS</em> have an <code>inbreed</code> option which uses an estimator of <span class="math inline">\(f_2\)</span> that is robust to inbreeding. This option is also recommended to use for pseudohaploid data. <em>ADMIXTOOLS 2</em> automatically detects pseudohaploid samples by checking if any heterozyous genotypes are observed among the first 1000 SNPs. If not, the sample is assumed to be pseudohaploid.</p>
</div>
<div id="bias-due-to-missing-data-and-snp-ascertainment" class="section level3">
<h3 class="hasAnchor">
<a href="#bias-due-to-missing-data-and-snp-ascertainment" class="anchor"></a>Bias due to missing data and SNP ascertainment</h3>
<p>Missing data alone will not create any bias in <span class="math inline">\(f_2\)</span> estimates, as long as the data are missing at random. However, if rare or common SNPs are more likely to be missing, <span class="math inline">\(f_2\)</span> can be over- or underestimated. In contrast to <span class="math inline">\(F_{ST}\)</span>, which is the same in expectation for rare and for common SNPs, <span class="math inline">\(f_2\)</span> tends to be larger for common SNPs. Strictly speaking, there is no such thing as an unbiasd <span class="math inline">\(f_2\)</span> estimate, since it always depends on the allele frequency spectrum of ascertained SNPs. What’s important in practice is that there are no systematic differences in ascertainment among the populations in an analysis. <em>ADMIXTOOLS</em> draws most of its inferences from comparing allele frequency differences between populations, which means that biases that affect all populations equally are not very important. If, however, one pair of populations has a high <span class="math inline">\(f_2\)</span> because most rare alleles are missing in one of the populations, and another pair of populations has a lower <span class="math inline">\(f_2\)</span> beause those rare alleles are not missing, bias can be expected.</p>
<p>One way to prevent this bias is to not use any SNPs which are missing in one or more populations, although this may not leave enough SNPs to have sufficient statistical power. In the original <em>ADMIXTOOLS</em> software, the <code>allsnps</code> options toggles between using only SNPs which are present in all populations in an analysis, and the largest possible number of SNPs for each f-statistic. In <em>ADMIXTOOLS 2</em>, the <code>maxmiss</code> parameter in <code><a href="../reference/extract_f2.html">extract_f2()</a></code> which ranges from 0 to 1 can be used to exclude SNPs which are missing in more than a specific fraction of all populations. This can be used to find a balance between statistical power and the potential for bias.</p>
<p>As mentioned earlier, estimating <span class="math inline">\(f_4\)</span> without bias is actually easier than estimating <span class="math inline">\(f_2\)</span> or <span class="math inline">\(F_{ST}\)</span> without any bias.</p>
</div>
</div>
<div id="f-statistics-in-admixtools-2" class="section level2">
<h2 class="hasAnchor">
<a href="#f-statistics-in-admixtools-2" class="anchor"></a><em>f</em>-statistics in <em>ADMIXTOOLS 2</em>
</h2>
<p>In <em>ADMIXTOOLS 2</em>, the simplest way to compute <em>f</em>-statistics from genotype data is to use <code><a href="../reference/f2_from_geno.html">f2_from_geno()</a></code>.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>genotype_data =<span class="st"> "/my/geno/prefix"</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>f2_blocks =<span class="st"> </span><span class="kw"><a href="../reference/f2_from_geno.html">f2_from_geno</a></span>(genotype_data)</span></code></pre></div>
<p>However, in most cases it will save you time to store <span class="math inline">\(f_2\)</span>-statistics on disk in a way that lets you access only some of the population pairs.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>genotype_data =<span class="st"> "/my/geno/prefix"</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>f2_dir =<span class="st"> "/my/f2/directory/"</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw"><a href="../reference/extract_f2.html">extract_f2</a></span>(genotype_data, f2_dir)</span>
<span id="cb3-4"><a href="#cb3-4"></a>f2_blocks =<span class="st"> </span><span class="kw"><a href="../reference/f2_from_precomp.html">f2_from_precomp</a></span>(f2_dir, <span class="dt">pops =</span> <span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">"pop1"</span>, <span class="st">"pop2"</span>, <span class="st">"pop3"</span>))</span></code></pre></div>
<p>In addition to that, there are several more functions which are useful to extract data in a way that doesn’t require you to commit to a fixed assignment of individuals to populations (<code><a href="../reference/extract_counts.html">extract_counts()</a></code>), and function which make the process more memory efficient and easier to parallelize in case you want to extract data for a large number of individuals or populations (<code><a href="../reference/extract_afs.html">extract_afs()</a></code>, <code><a href="../reference/afs_to_f2.html">afs_to_f2()</a></code>, <code><a href="../reference/afs_to_counts.html">afs_to_counts()</a></code>).</p>
<p>The following schematic gives an overview of these functions:</p>
<p><img src="images/extract_functions.png"></p>
<p>Arguments to these functions can be used to decide</p>
<ul>
<li>For which samples or populations to compute <span class="math inline">\(f_2\)</span>-statistics</li>
<li>Which SNPs to use
<ul>
<li>thresholds for missingness and allele frequency, transitions only, …</li>
</ul>
</li>
<li>How SNPs should be grouped into blocks
<ul>
<li>defaults to blocks of 5 centimorgan</li>
</ul>
</li>
<li>Whether pseudohaploid samples should be detected automatically
<ul>
<li>recommended; can be set to <code>FALSE</code> to match the original <em>ADMIXTOOLS</em>
</li>
</ul>
</li>
</ul>
<p>For example, the folllowing command would extract data for the populations <code>mypops</code>, keeping only SNPs which are missing in no more than 10% of the populations, and grouping SNPs into blocks of 10 centimorgan.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw"><a href="../reference/extract_f2.html">extract_f2</a></span>(genotype_data, f2_dir, <span class="dt">pops =</span> mypops, <span class="dt">maxmiss =</span> <span class="fl">0.1</span>, <span class="dt">blgsize =</span> <span class="fl">0.1</span>)</span></code></pre></div>
<div id="allele-frequency-products" class="section level3">
<h3 class="hasAnchor">
<a href="#allele-frequency-products" class="anchor"></a>Allele frequency products</h3>
<p><code><a href="../reference/extract_f2.html">extract_f2()</a></code> computes and stores both regular <span class="math inline">\(f_2\)</span>-estimates, and allele frequency product estimates. In most cases, the allele frequency products will not be needed, but if there is a concern that missing data introduces bias, they can be used for computing f4-statistics and loaded like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>my_f2_dir =<span class="st"> '/store/f2data/here/'</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>afprod_blocks =<span class="st"> </span><span class="kw"><a href="../reference/f2_from_precomp.html">f2_from_precomp</a></span>(my_f2_dir, <span class="dt">afprod =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
<p>This creates a 3d array just like <code>f2_blocks</code>, but it will contain allele frequency products rather than <span class="math inline">\(f_2\)</span>-statistics. For any <em>ADMIXTOOLS</em> application based on <span class="math inline">\(f_4\)</span>-statistics, this allele frequency product array can be used just like the regular <span class="math inline">\(f_2\)</span> array. It will give close to identical results, but without any bias introduced by poor <span class="math inline">\(f_2\)</span>-estimates.</p>
<p>Computing allele frequency products is simpler than computing <span class="math inline">\(f_2\)</span> (allele frequency products are a part of <span class="math inline">\(f_2\)</span>), but two things need to be done differently to get unbiased estimates:</p>
<ol style="list-style-type: decimal">
<li><p>In contrast to <span class="math inline">\(f_2\)</span>, for allele frequency products the designation of reference and alternative alleles can make a difference. To get estimates which are independent of that, we average over both options for each SNP. (If the alelle frequencies at a SNP are <code>0.1</code> and <code>0.2</code> in two populations, we compute <code>((0.1 * 0.2) + (0.9 * 0.8))/2</code> instead of just <code>0.1 * 0.2</code>)</p></li>
<li><p><em>ADMIXTOOLS</em> excludes any SNPs with identical allele frequencies in all populations. This makes very little differences when computing <span class="math inline">\(f_2\)</span>, but shouldn’t be done for allele frequency products. Because those SNPs are not excluded, the number of SNPs and the number of blocks can be larger for allele frequency products than for <span class="math inline">\(f_2\)</span>.</p></li>
</ol>
</div>
<div id="extracting-f2-for-a-large-number-of-populations" class="section level3">
<h3 class="hasAnchor">
<a href="#extracting-f2-for-a-large-number-of-populations" class="anchor"></a>Extracting <em>f</em><sub>2</sub> for a large number of populations</h3>
<p><code><a href="../reference/extract_f2.html">extract_f2()</a></code> will only work when extracting data for a moderate number of populations because it keeps the allele frequency matrix for all SNPs and populations in memory. If <code><a href="../reference/extract_f2.html">extract_f2()</a></code> runs out of memory, you can either reduce the number of populations, or set the <code>cols_per_chunk</code> argument in <code><a href="../reference/extract_f2.html">extract_f2()</a></code> to a positive integer, for example 10. This will split the allele frequency matrix into chunks and saves each chunk on disk. This is slower, but less memory intensive, and will perform two operations:</p>
<ol style="list-style-type: decimal">
<li>Saving the allele frequency chunks with <code><a href="../reference/extract_afs.html">extract_afs()</a></code>
</li>
<li>Computing <span class="math inline">\(f_2\)</span> for each pair of chunks with <code><a href="../reference/afs_to_f2.html">afs_to_f2()</a></code>
</li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>genotype_data =<span class="st"> "/my/geno/prefix"</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>outdir =<span class="st"> "/store/f2data/here/"</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co"># 1st Step</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw"><a href="../reference/extract_afs.html">extract_afs</a></span>(genotype_data, outdir, <span class="dt">cols_per_chunk =</span> <span class="dv">10</span>)</span>
<span id="cb6-6"><a href="#cb6-6"></a>numchunks =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/length.html">length</a></span>(<span class="kw"><a href="https://rdrr.io/r/base/list.files.html">list.files</a></span>(outdir, <span class="st">'afs.+rds'</span>))</span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co"># 2nd Step</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="cf">for</span>(j <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>numchunks) {</span>
<span id="cb6-10"><a href="#cb6-10"></a>  <span class="cf">for</span>(j <span class="cf">in</span> i<span class="op">:</span>numchunks) {</span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw"><a href="../reference/afs_to_f2.html">afs_to_f2</a></span>(outdir, outdir, <span class="dt">chunk1 =</span> i, <span class="dt">chunk2 =</span> j)</span>
<span id="cb6-12"><a href="#cb6-12"></a>  }</span>
<span id="cb6-13"><a href="#cb6-13"></a>}</span></code></pre></div>
<p>Increasing <code>cols_per_chunk</code> in the first step can speed things up, but will require more memory in the second step. Once <code><a href="../reference/extract_afs.html">extract_afs()</a></code> has finished, <span class="math inline">\(f_2\)</span>-statistics can be computed for each pair of chunks.</p>
<p>The second step can take a long time when running one pair after another, so it can make sense to run the calls to <code><a href="../reference/afs_to_f2.html">afs_to_f2()</a></code> in parallel.</p>
</div>
<div id="extracting-f2-for-arbitrary-populations" class="section level3">
<h3 class="hasAnchor">
<a href="#extracting-f2-for-arbitrary-populations" class="anchor"></a>Extracting <em>f</em><sub>2</sub> for arbitrary populations</h3>
<p>What if you decide that a particular sample should be added or removed from a population? With the approach described so far, you would have to go back to the genotype data to get new estimates of <span class="math inline">\(f_2\)</span> for all pairs of the modified population and any other populations. Even if you had computed <span class="math inline">\(f_2\)</span> for all pairs of individuals (rather than for pairs of populations), it would not be possible to combine the <span class="math inline">\(f_2\)</span> statistics from individual pairs into <span class="math inline">\(f_2\)</span> statistics on population pairs formed from these individuals. It <em>is</em> possible, however, to store <em>other</em> statistics for all individuals and individual pairs, which can be combined into estimates of <span class="math inline">\(f_2\)</span> for any populations formed from these individuals. These statistics are the mean alternative allele counts (<code>a</code>) and total allele counts (<code>n</code>) for each individual and block, and the mean products of allele counts for all individual pairs (<code>aa</code> and <code>nn</code>).</p>
<p>The upside of this approach is that it allows you to change population definitions however you like and still get very fast results without accessing the genotype data more than once. The downside is that it makes it necessary to store data for all individual pairs, rather than just all population pairs. Besides taking more disk space, this also makes it a bit slower to get <span class="math inline">\(f_2\)</span>-statistics into R.</p>
<p>The following function extracts data for a set of individuals which can then be combined to get estimates of f2 for any populations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>inds =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'Chimp.REF'</span>, <span class="st">'Altai_snpAD.DG'</span>, <span class="st">'Vindija_snpAD.DG'</span>,</span>
<span id="cb7-2"><a href="#cb7-2"></a>         <span class="st">'S_Mbuti-3.DG'</span>, <span class="st">'B_Mbuti-4.DG'</span>, <span class="st">'S_Mbuti-2.DG'</span>, <span class="st">'S_Mbuti-1.DG'</span>,</span>
<span id="cb7-3"><a href="#cb7-3"></a>         <span class="st">'Denisova_snpAD.DG'</span>, <span class="st">'UstIshim_snpAD.DG'</span>, <span class="st">'Bichon.SG'</span>)</span>
<span id="cb7-4"><a href="#cb7-4"></a>my_counts_dir =<span class="st"> 'my/counts/dir'</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="kw"><a href="../reference/extract_counts.html">extract_counts</a></span>(prefix, my_counts_dir, inds)</span></code></pre></div>
<p>You can again use <code><a href="../reference/f2_from_precomp.html">f2_from_precomp()</a></code> to load a subset of the extracted data into memory. If the directory you provide contains allele count data rather than <span class="math inline">\(f_2\)</span>-statistics, this function will not only read the data, but combine it into <span class="math inline">\(f_2\)</span>-statistics for populations that you define. The populations can be defined by providing a vector of individuals and another vector of equal length with population labels.</p>
<p>For example, the following code should return <span class="math inline">\(f_2\)</span>-statistics very similar to the <span class="math inline">\(f_2\)</span>-statistics in the earlier examples. They will not be exactly identical, because the set of SNPs used and the SNP block boundaries usually differ a little bit when filtering SNPs based on sample and based on population missingness. In addition, some approximations are necessary when computing <span class="math inline">\(f_2\)</span>-statistics this way. However, if you fix the set of SNPs with the <code>keepsnps</code> argument, the difference should be very small.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a>pops =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'Chimp'</span>, <span class="st">'Altai'</span>, <span class="st">'Vindija'</span>,</span>
<span id="cb8-2"><a href="#cb8-2"></a>         <span class="st">'Mbuti'</span>, <span class="st">'Mbuti'</span>, <span class="st">'Mbuti'</span>, <span class="st">'Mbuti'</span>,</span>
<span id="cb8-3"><a href="#cb8-3"></a>         <span class="st">'Denisova'</span>, <span class="st">'Russia'</span>, <span class="st">'Switzerland'</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a>f2_blocks_v2 =<span class="st"> </span><span class="kw"><a href="../reference/f2_from_precomp.html">f2_from_precomp</a></span>(my_counts_dir, <span class="dt">inds =</span> inds, <span class="dt">pops =</span> pops)</span></code></pre></div>
<p>It’s now easy to test how the inclusion or exclusion of specific samples affects the fit of a model. The following example uses only two Mbuti samples, and combines the two Neanderthal samples into one group.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a>inds_v3 =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'Chimp.REF'</span>, <span class="st">'Altai_snpAD.DG'</span>, <span class="st">'Vindija_snpAD.DG'</span>,</span>
<span id="cb9-2"><a href="#cb9-2"></a>            <span class="st">'S_Mbuti-2.DG'</span>, <span class="st">'S_Mbuti-1.DG'</span>,</span>
<span id="cb9-3"><a href="#cb9-3"></a>            <span class="st">'Denisova_snpAD.DG'</span>, <span class="st">'UstIshim_snpAD.DG'</span>, <span class="st">'Bichon.SG'</span>)</span>
<span id="cb9-4"><a href="#cb9-4"></a>pops_v3 =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'Chimp'</span>, <span class="st">'Neanderthal'</span>, <span class="st">'Neanderthal'</span>,</span>
<span id="cb9-5"><a href="#cb9-5"></a>            <span class="st">'Mbuti'</span>, <span class="st">'Mbuti'</span>,</span>
<span id="cb9-6"><a href="#cb9-6"></a>            <span class="st">'Denisova'</span>, <span class="st">'Russia'</span>, <span class="st">'Switzerland'</span>)</span>
<span id="cb9-7"><a href="#cb9-7"></a>f2_blocks_v3 =<span class="st"> </span><span class="kw"><a href="../reference/f2_from_precomp.html">f2_from_precomp</a></span>(my_counts_dir, <span class="dt">inds =</span> inds_v3, <span class="dt">pops =</span> pops_v3)</span></code></pre></div>
<p><br></p>
<p>This approach is very flexible, but it gets slow when some populations consist of large numbers of samples. If you find yourself in this situation, you can group individuals into populations and store the combined allele count data for those populations on disk. The following example stores a <code>Mbuti</code> group on disk, and then uses that group, rather than each sample in it, to compute <span class="math inline">\(f_2\)</span>-statistics.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>mbuti =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'S_Mbuti-3.DG'</span>, <span class="st">'B_Mbuti-4.DG'</span>, <span class="st">'S_Mbuti-2.DG'</span>, <span class="st">'S_Mbuti-1.DG'</span>)</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="kw"><a href="../reference/group_samples.html">group_samples</a></span>(my_counts_dir, mbuti, <span class="st">'Mbuti'</span>)</span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a>inds_v4 =<span class="st"> </span><span class="kw"><a href="https://rdrr.io/r/base/c.html">c</a></span>(<span class="st">'Chimp.REF'</span>, <span class="st">'Altai_snpAD.DG'</span>, <span class="st">'Vindija_snpAD.DG'</span>, <span class="st">'Mbuti'</span>,</span>
<span id="cb10-5"><a href="#cb10-5"></a>            <span class="st">'Denisova_snpAD.DG'</span>, <span class="st">'UstIshim_snpAD.DG'</span>, <span class="st">'Bichon.SG'</span>)</span>
<span id="cb10-6"><a href="#cb10-6"></a>f2_blocks_v4 =<span class="st"> </span><span class="kw"><a href="../reference/f2_from_precomp.html">f2_from_precomp</a></span>(my_counts_dir, <span class="dt">inds =</span> inds_v4)</span></code></pre></div>
<p>Data from these groups can be deleted like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw"><a href="../reference/delete_groups.html">delete_groups</a></span>(my_counts_dir, <span class="st">'Mbuti'</span>)</span></code></pre></div>
<p><br></p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#f2"><em>f</em><sub>2</sub></a></li>
      <li><a href="#f4"><em>f</em><sub>4</sub></a></li>
      <li><a href="#biases">Biases</a></li>
      <li><a href="#f-statistics-in-admixtools-2"><em>f</em>-statistics in <em>ADMIXTOOLS 2</em></a></li>
      </ul>
</div>
      </div>

</div>



      <footer><div class="copyright">
  <p>Developed by Robert Maier, Nick Patterson.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.4.1.</p>
</div>

      </footer>
</div>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/docsearch.js/2.6.1/docsearch.min.js" integrity="sha256-GKvGqXDznoRYHCwKXGnuchvKSwmx9SRMrZOTh2g4Sb0=" crossorigin="anonymous"></script><script>
  docsearch({
    
    
    apiKey: 'c30b6be96312414d83a0ba52b94b558b',
    indexName: 'admixtools',
    inputSelector: 'input#search-input.form-control',
    transformData: function(hits) {
      return hits.map(function (hit) {
        hit.url = updateHitURL(hit);
        return hit;
      });
    }
  });
</script>
</body>
</html>
