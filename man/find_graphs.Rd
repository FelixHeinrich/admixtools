% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/toposearch.R
\name{find_graphs}
\alias{find_graphs}
\title{Find well fitting admixture graphs}
\usage{
find_graphs(
  data,
  pops = NULL,
  outpop = NULL,
  numrep = 1,
  numgraphs = 50,
  numgen = 5,
  numsel = 5,
  numadmix = 0,
  numstart = 1,
  keep = c("all", "best", "last"),
  initgraphs = NULL,
  mutfuns = namedList(spr_leaves, spr_all, swap_leaves, move_admixedge_once,
    flipadmix_random, mutate_n),
  mutprobs = NULL,
  opt_worst_residual = FALSE,
  store_intermediate = NULL,
  parallel = TRUE,
  stop_after = NULL,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{data}{Input data in one of three forms:
\enumerate{
\item A 3d array of blocked f2 statistics, output of \code{\link{f2_from_precomp}} or \code{\link{extract_f2}} (fastest option)
\item A directory which contains pre-computed f2-statistics
\item The prefix of genotype files (slowest option)
}}

\item{pops}{Populations for which to fit admixture graphs (default all)}

\item{outpop}{An outgroup population which will split at the root from all other populations in all tested graphs. If one of the populations is know to be an outgroup, designating it as \code{outpop} will greatly reduce the search space compared to including it and not designating it as \code{outpop}.}

\item{numrep}{Number of independent repetitions (each repetition can be run in parallel)}

\item{numgraphs}{Number of graphs in each generation}

\item{numgen}{Number of generations}

\item{numsel}{Number of graphs which are selected in each generation. Should be less than \code{numgraphs}.}

\item{numadmix}{Number of admixture events within each graph}

\item{numstart}{Number of random initializations in each call to \code{qpgraph}. Defaults to 1, to speed up the graph optimization.}

\item{keep}{Which models should be returned. One of \code{all}, \code{best}, \code{last}
\itemize{
\item \code{all} (default): Return all evaluated graphs
\item \code{best}: Return only the best fitting graph from each repeat and each generation
\item \code{last}: Return all graphs from the last generation
}}

\item{initgraphs}{Optional graph or list of igraphs to start with. If \code{NULL}, optimization will start with random graphs.}

\item{mutfuns}{Functions used to modify graphs. Defaults to the following:
\itemize{
\item \code{\link{spr_leaves}}: Subtree prune and regraft leaves. Cuts a leaf node and attaches it
to a random other edge in the graph.
\item \code{\link{spr_all}}: Subtree prune and regraft. Cuts any edge and attaches the new orphan node
to a random other edge in the graph, keeping the number of admixture nodes constant.
\item \code{\link{swap_leaves}}: Swaps two leaf nodes.
\item \code{\link{move_admixedge_once}}: Moves an admixture edge to a nearby location.
\item \code{\link{flipadmix_random}}: Flips the direction of an admixture edge (if possible).
\item \code{\link{mutate_n}}: Apply \code{n} of the mutation functions in this list to a graph (defaults to 2).
}
See examples for how to make new mutation functions.}

\item{mutprobs}{Relative frequencies of each mutation function.
\itemize{
\item \code{NULL} (default) means each mutation function is picked with equal probability
\item A numeric vector of length equal to \code{mutfuns} defines the relative frequency of each mutation function
\item A matrix of dimensions \code{numgen} x \code{length(mutfuns)} defines the relative frequency of each mutation function in each generation
}}

\item{opt_worst_residual}{Optimize for lowest worst residual instead of best score. \code{FALSE} by default, because the likelihood score is generally a better indicator of the quality of the model fit. Optimizing for the lowest worst residual is also slower (because f4-statistics need to be computed).}

\item{store_intermediate}{Path and prefix of files for intermediate results to \code{.rds}. Can be useful if \code{find_graphs} doesn't finish sucessfully.}

\item{parallel}{Parallelize over repeats (if \code{numrep > 1}) or graphs (if \code{numrep == 1}) by replacing \code{\link[purrr]{map}} with \code{\link[furrr]{future_map}}. Will only be effective if \code{\link[future]{plan}} has been set.}

\item{stop_after}{Stop optimization after \code{stop_after} seconds (and after finishing the current generation).}

\item{verbose}{Print progress updates}

\item{...}{Additional arguments passed to \code{\link{qpgraph}}}
}
\value{
A nested data frame with one model per line
}
\description{
This function generates and evaluates admixture graphs in \code{numgen} iterations across \code{numrep} independent repeats
to find well fitting admixturegraphs. It uses the function \code{\link[furrr]{future_map}}
to parallelize across the independent repeats. The function \code{\link[future]{plan}} can be called
to specify the details of the parallelization. This can be used to parallelize across cores or across nodes on
a compute cluster. Setting \code{numadmix} to 0 will search for well fitting trees, which is much faster than searching
for admixture graphs with many admixture nodes.
}
\examples{
\dontrun{
find_graphs(example_f2_blocks, numrep = 200, numgraphs = 100,
            numgen = 20, numsel = 5, numadmix = 3)
}
\dontrun{
# Making new mutation functions by modifying or combining existing ones:
newfun1 = function(graph, ...) mutate_n(graph, 3, ...)
newfun2 = function(graph, ...) flipadmix_random(spr_leaves(graph, ...), ...)
find_graphs(f2_blocks, mutfuns = namedList(spr_leaves, newfun1, newfun2), mutprobs = c(0.2, 0.3, 0.5))
}
}
\seealso{
\code{\link{qpgraph}}
}
