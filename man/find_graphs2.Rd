% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/toposearch.R
\name{find_graphs2}
\alias{find_graphs2}
\title{Find well fitting admixture graphs}
\usage{
find_graphs2(
  f2_blocks,
  numgen = 1,
  numgraphs = 10,
  numadmix = 0,
  stopscore = 0,
  stop_after = NULL,
  stopafter_noimprovement = 15,
  initgraph = NULL,
  outpop = NULL,
  mutfuns = namedList(spr_leaves, spr_all, swap_leaves, move_admixedge_once,
    flipadmix_random, mutate_n),
  opt_worst_residual = FALSE,
  plusminus_generations = 5,
  admix_constraints = NULL,
  event_constraints = NULL,
  reject_f4z = 0,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{f2_blocks}{A 3d array of blocked f2 statistics, output of \code{\link{f2_from_precomp}} or \code{\link{extract_f2}}}

\item{numgen}{Number of generations}

\item{numgraphs}{Number of graphs in each generation}

\item{numadmix}{Number of admixture events within each graph. (Only relevant if \code{initgraph = NULL})}

\item{mutfuns}{Functions used to modify graphs. Defaults to the following:
\itemize{
\item \code{\link{spr_leaves}}: Subtree prune and regraft leaves. Cuts a leaf node and attaches it
to a random other edge in the graph.
\item \code{\link{spr_all}}: Subtree prune and regraft. Cuts any edge and attaches the new orphan node
to a random other edge in the graph, keeping the number of admixture nodes constant.
\item \code{\link{swap_leaves}}: Swaps two leaf nodes.
\item \code{\link{move_admixedge_once}}: Moves an admixture edge to a nearby location.
\item \code{\link{flipadmix_random}}: Flips the direction of an admixture edge (if possible).
\item \code{\link{mutate_n}}: Apply \code{n} of the mutation functions in this list to a graph (defaults to 2).
}}

\item{opt_worst_residual}{Optimize for lowest worst residual instead of best score. \code{FALSE} by default, because the likelihood score is generally a better indicator of the quality of the model fit, and because optimizing for the lowest worst residual is slower (because f4-statistics need to be computed).}

\item{plusminus_generations}{If the best score does not improve after \code{plusminus_generations} generations, another approach to improving the score will be attempted: A number of graphs with on additional admixture edge will be generated and evaluated. The resulting graph with the best score will be picked, and new graphs will be created by removing any one admixture edge (bringing the number back to what it was originally). The graph with the lowest score will then be selected. This often makes it possible to break out of local optima, but is slower than regular graph modifications.}

\item{admix_constraints}{A data frame with constraints on the number of admixture events for each population.
See \code{\link{satisfies_numadmix}}
As soon as one graph happens to satisfy these constraints, all subsequently generated graphs will be required to also satisfy them.}

\item{event_constraints}{A data frame with constraints on the order of events in an admixture graph.
See \code{\link{satisfies_eventorder}}
As soon as one graph happens to satisfy these constraints, all subsequently generated graphs will be required to also satisfy them.}

\item{reject_f4z}{If this is a number greater than zero, all f4-statistics with \code{z > reject_f4z} will be used to constrain the search space of admixture graphs: Any graphs in which any of the relevant f4-statistics are expected to be zero will not be evaluated.}

\item{verbose}{Print progress updates}

\item{...}{Additional arguments passed to \code{\link{qpgraph}}}
}
\value{
A nested data frame with one model per line
}
\description{
This function generates and evaluates admixture graphs in \code{numgen} iterations
to find well fitting admixturegraphs.
}
\examples{
\dontrun{
pops = dimnames(example_f2_blocks)[[1]]
initgraph = random_admixturegraph(pops, 2, outpop = 'Chimp.REF')
res = find_graphs2(example_f2_blocks, initgraph, numgen = 100)
res \%>\% slice_min(score)
}
\dontrun{
# Making new mutation functions by modifying or combining existing ones:
newfun1 = function(graph, ...) mutate_n(graph, 3, ...)
newfun2 = function(graph, ...) flipadmix_random(spr_leaves(graph, ...), ...)
find_graphs(f2_blocks, mutfuns = namedList(spr_leaves, newfun1, newfun2), mutprobs = c(0.2, 0.3, 0.5))
}
}
\seealso{
\code{\link{qpgraph}}
}
